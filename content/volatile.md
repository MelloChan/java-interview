### volatile

#### 特性:  

①保证不同对象对修饰变量的内存可见性;  
②禁止指令重排序.  

#### JMM

首先了解下JMM(Java内存模型),JMM的目的是为了屏蔽不同硬件与OS对内存访问的差异,让Java程序在各种平台上有一致的内存访问.如下图,工作内存对应高速缓存,因为CPU指令执行的速度相对比访问内存的速度,两者不是一个数量级,因此为了加快访问速度而增设了临近CPU的高速缓存块.而JMM映射了这种模型.    
![内存模型](https://raw.githubusercontent.com/MelloChan/java-interview/master/image/JMM.png)  
工作内存是线程私有的,而主内存存储着各类全局变量,线程访问变量则需要从主内存中读取载入到自身工作内存.对变量进行相应操作后,才会重新存储写入到主内存,以此更新变量值.这些操作在单线程下不会出现问题,但多线程下就会出现并发问题了,因为虽然单一操作本身是原子性的,但组合起来就不一定了.  
例如:
```aidl
// int i = 0;
  i++; 
```
i++的操作并不是原子性的,他首先从内存中读取载入到工作内存,随后进行+1操作,然后赋值在存储写入主内存.
```aidl
// 假设有两个线程执行 i++
线程①:  从主存读取 i,  // i = 0  read->load
         对 i + 1,    // i = 1 假设此时时间片到时,线程切换 use assign
线程②:  从主存读取 i,  // 此时 线程①的操作还未写入主存,因此 i = 0
         对 i + 1,     
         将i写入主存    // store write i = 1 此时再次线程切换
线程①:  将i写入主存    // store write i = 1             
```
如上的执行流程,i的最终值将会是1(甚至可能是0),这就产生了缓存不一致的问题.  
而要解决缓存不一致问题,实质上就是如何处理JMM的原子性/可见性/有序性三个特性的问题,而volatile能够解决可见性与有序性.  

原子性:    
可见性:   
有序性:  

#### volatile对于可见性以及有序性的保证






