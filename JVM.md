### JVM  
- 运行时数据区  
![运行时数据区](https://raw.githubusercontent.com/MelloChan/java-interview/master/image/JVM.png)   

pc:程序计数器,是一块占用较少内存的空间,用来存放线程运行的下条指令,是线程私有的.需要注意的是当执行的是本地(Native)方法时,计数器值为空,另外这也是唯一不会有OOM情况的区域;  
  
虚拟机栈:线程私有的.会为每个方法执行的时候创建一个栈帧用于存储局部变量表/操作数栈/动态链接/方法出口等信息.
一个方法的调用->执行完成,就是一个栈帧入栈出栈的过程.    
局部变量表存放了编译期可知的各种基本数据类型/对象引用类型.在编译期就会完成内存空间分配.当进入一个方法时,这个方法需要在栈帧中分配多大的局部变量空间就已经确定,运行期不会被改变.  
会出现的异常状况:SOE(StackOverflowError) & OOM(OutOfMemoryError);  

本地方法栈:发挥的作用和虚拟机栈相似.只不过执行的是本地方法.在虚拟机规范中对本地方法栈中方法使用的语言/使用方式与数据结构并没有强制规定,因此具体的实现由虚拟机自由实现.与虚拟机栈一样可能出现异常状况:SOE & OOM;  

堆:JVM管理的最大的一块内存区域.线程共享,在启动时即被创建.主要用来存放对象实例(包括数组),基本所有(这里的例外是JIT技术)的对象实例都在此处分配内存.  
根据分代收集算法,堆还可细分为新生代(Eden/From Survivor/To Survivor 8:1:1)与老年代.另外根据需要还可划分出多个线程私有的分配缓冲区(TLAB).  
在堆内存耗尽且无法再扩展时抛出OOM;  

方法区:线程共享.用于存放已被虚拟机加载的类信息、常量、静态变量、JIT(即时编译器)编译好的代码等数据.  
会出现的异常状况:OOM(OutOfMemoryError);     

运行时常量池:方法区的一部分.类文件除了有类的版本、字段、方法、接口等描述信息外,还有一项是常量池,用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放.
此外运行时常量池具备动态性.Java不要求常量一定只有编译期才能产生,运行期间也可能将新的常量放入池中,String的intern()方法就是例子.  
会出现的异常状况:OOM(OutOfMemoryError);     

直接内存:并不属于JVM运行时数据区的一部分.具体的应用可参考JDK1.4后引入的NIO.可调用本地方法直接分配堆外内存.作用是提高性能.避免在Java堆和本地堆中来回复制数据.      
会出现的异常状况:OOM(OutOfMemoryError).       

- 对象

- 溢出与泄露

- 内存模型
![内存模型](https://raw.githubusercontent.com/MelloChan/java-interview/master/image/JMM.png)

- 垃圾回收算法
- 垃圾收集器
- 内存分配与回收策略
- 类加载过程
- 类加载器
- 启动参数