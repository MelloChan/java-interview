### JVM  
- 运行时数据区  
![运行时数据区](https://raw.githubusercontent.com/MelloChan/java-interview/master/image/JVM.png)   

pc:程序计数器,是一块占用较少内存的空间,用来存放线程运行的下条指令,是线程私有的.需要注意的是当执行的是本地(Native)方法时,计数器值为空,另外这也是唯一不会有OOM情况的区域;  
  
虚拟机栈:线程私有的.会为每个方法执行的时候创建一个栈帧用于存储局部变量表/操作数栈/动态链接/方法出口等信息.
一个方法的调用->执行完成,就是一个栈帧入栈出栈的过程.    
局部变量表存放了编译期可知的各种基本数据类型/对象引用类型.在编译期就会完成内存空间分配.当进入一个方法时,这个方法需要在栈帧中分配多大的局部变量空间就已经确定,运行期不会被改变.  
会出现的异常状况:SOE(StackOverflowError) & OOM(OutOfMemoryError);  

本地方法栈:发挥的作用和虚拟机栈相似.只不过执行的是本地方法.在虚拟机规范中对本地方法栈中方法使用的语言/使用方式与数据结构并没有强制规定,因此具体的实现由虚拟机自由实现.与虚拟机栈一样可能出现异常状况:SOE & OOM;  

堆:JVM管理的最大的一块内存区域.线程共享,在启动时即被创建.主要用来存放对象实例(包括数组),基本所有(这里的例外是JIT技术)的对象实例都在此处分配内存.  
根据分代收集算法,堆还可细分为新生代(Eden/From Survivor/To Survivor 8:1:1)与老年代.另外根据需要还可划分出多个线程私有的分配缓冲区(TLAB).  
在堆内存耗尽且无法再扩展时抛出OOM;  

方法区:线程共享.用于存放已被虚拟机加载的类信息、常量、静态变量、JIT(即时编译器)编译好的代码等数据.  
会出现的异常状况:OOM(OutOfMemoryError);     

运行时常量池:方法区的一部分.类文件除了有类的版本、字段、方法、接口等描述信息外,还有一项是常量池,用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放.
此外运行时常量池具备动态性.Java不要求常量一定只有编译期才能产生,运行期间也可能将新的常量放入池中,String的intern()方法就是例子.  
会出现的异常状况:OOM(OutOfMemoryError);     

直接内存:并不属于JVM运行时数据区的一部分.具体的应用可参考JDK1.4后引入的NIO.可调用本地方法直接分配堆外内存.作用是提高性能.避免在Java堆和本地堆中来回复制数据.      
会出现的异常状况:OOM(OutOfMemoryError).       

- 对象  

对象的创建:①new XXClass();②clone方法;③反射机制  
 
创建过程:类加载->堆分配内存->初始化为0值->引用赋值->执行\<init>,按照使用者的意志初始化.  
 
内存的分配:①指针碰撞法,将堆划分为使用的一方与空闲的一方,中间利用指针作为分界点.要求堆内存是规整的;②空闲列表,一个记录空闲内存的列表,当对象需要分配内存时就从列表就找到一块足够大的空间进行分配.  
 
并发问题:①CAS,同步分配保证原子性;②设置TLAB,堆中设置线程私有缓存,用于空间分配,不够在另外申请; 
  
对象的内存布局:①对象头,包括两部分信息,一部分用于存储对象自身的运行时数据(哈希码/GC分代年龄/锁转态标志/线程持有的锁/偏向线程ID/偏向时间戳等),另一部分则是类型指针,用于指向对象的类元数据,JVM以此确定此对象是哪个类的实例.另外数组作为Java对象,对象头还有一块用于记录数组大小;    
②实例数据,对象真正存储的有效信息,是在程序代码中所定义的各种类型的字段内容;    
③对齐填充,不是必然存在的部分,仅仅起着占位符的作用,只是因为JVM的自动内存管理系统要求对象起始地址必须是8字节的整数倍(对象的大小必须是8字节的整数倍).       

对象的访问定位:①句柄访问,将堆分为句柄池与实例池.Java栈中本地变量表存储着指向句柄池的引用,而句柄中包含了对象实例数据与类型数据(方法区)各自的地址信息;  
②直接指针访问,栈中存储的引用直接指向堆的实例数据,而同时必须考虑如何设置访问类型数据的相关信息.  
句柄的好处在于稳定,在对象被移动时只会改变句柄中的实例数据指针,而栈引用无需改变;直接指针好处在于快速访问.  
![句柄池](https://raw.githubusercontent.com/MelloChan/java-interview/master/image/%E5%8F%A5%E6%9F%84%E6%B1%A0.jpg)  
![直接指针](https://raw.githubusercontent.com/MelloChan/java-interview/master/image/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.jpg)  

- [OOM & SOF](https://github.com/MelloChan/java-interview/blob/master/java-exam/src/jvm)  
①堆溢出;②栈溢出;③方法区和运行时常量池溢出;④本机直接内存溢出.  

- 内存模型  
![内存模型](https://raw.githubusercontent.com/MelloChan/java-interview/master/image/JMM.png)

- 垃圾回收算法  
 对象存活的判定:  
①[引用计数法](https://github.com/MelloChan/java-interview/blob/master/java-exam/src/jvm/ReferenceCountingGC.java),当对象被引用时,对象计数器+1,当引用失效时-1;只要计数器值为0则视为可回收对象被回收.这种算法实现简单,判定效率高,但会出现循环引用问题;    
②[可达性分析]()通过一系列的称为"GC Roots"的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链,当一个对象到GC Roots没有任何引用链相连时,对象即不可用,将被回收.  
可作为GC Roots的对象包括:虚拟机栈中引用的对象;方法区中静态属性引用的对象;方法区中常量引用的对象;本地方法栈中JNI引用的对象.    
引用划分:强引用(引用存在则不会被回收)、软引用(OOM将要发生时会被回收)、弱引用(GC时不论内存是否足够都将被回收)、虚引用(唯一作用在某个对象被回收时能收到系统通知).  
另外,即使对象即使被分析为不可达的,也不意味着立即回收,实际上至少经历两次标记,对象才会真正被回收.第一次标记后对象会经历一次筛选过程,JVM判断对象是否有必要执行finalize()方法,当对象没有覆盖该方法或该方法已经被执行过,则虚拟机视为没必要执行finalize(),否则执行,这也是对象逃脱回收的最后一次机会.在第二次标记时,若对象仍然不被GC Roots引用,则被回收.  
标记-清除:
标记-整理:
复制算法:
分代算法:

- 垃圾收集器  
- 内存分配与回收策略  
- 类加载过程  
- 类加载器  
- 启动参数  