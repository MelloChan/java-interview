### JVM  

- 运行时数据区  

![运行时数据区](https://raw.githubusercontent.com/MelloChan/java-interview/master/image/JVM.png)   

pc:程序计数器,是一块占用较少内存的空间,用来存放线程运行的下条指令,是线程私有的.需要注意的是当执行的是本地(Native)方法时,计数器值为空,另外这也是唯一不会有OOM情况的区域;  
  
虚拟机栈:线程私有的.会为每个方法执行的时候创建一个栈帧用于存储局部变量表/操作数栈/动态链接/方法出口等信息.
一个方法的调用->执行完成,就是一个栈帧入栈出栈的过程.    
局部变量表存放了编译期可知的各种基本数据类型/对象引用类型.在编译期就会完成内存空间分配.当进入一个方法时,这个方法需要在栈帧中分配多大的局部变量空间就已经确定,运行期不会被改变.  
会出现的异常状况:SOE(StackOverflowError) & OOM(OutOfMemoryError);  

本地方法栈:发挥的作用和虚拟机栈相似.只不过执行的是本地方法.在虚拟机规范中对本地方法栈中方法使用的语言/使用方式与数据结构并没有强制规定,因此具体的实现由虚拟机自由实现.与虚拟机栈一样可能出现异常状况:SOE & OOM;  

堆:JVM管理的最大的一块内存区域.线程共享,在启动时即被创建.主要用来存放对象实例(包括数组),基本所有(这里的例外是JIT技术)的对象实例都在此处分配内存.  
根据分代收集算法,堆还可细分为新生代(Eden/From Survivor/To Survivor 8:1:1)与老年代.另外根据需要还可划分出多个线程私有的分配缓冲区(TLAB).  
在堆内存耗尽且无法再扩展时抛出OOM;  

方法区:线程共享.用于存放已被虚拟机加载的类信息、常量、静态变量、JIT(即时编译器)编译好的代码等数据.  
会出现的异常状况:OOM(OutOfMemoryError);     

运行时常量池:方法区的一部分.类文件除了有类的版本、字段、方法、接口等描述信息外,还有一项是常量池,用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放.
此外运行时常量池具备动态性.Java不要求常量一定只有编译期才能产生,运行期间也可能将新的常量放入池中,String的intern()方法就是例子.  
会出现的异常状况:OOM(OutOfMemoryError);     

直接内存:并不属于JVM运行时数据区的一部分.具体的应用可参考JDK1.4后引入的NIO.可调用本地方法直接分配堆外内存.作用是提高性能.避免在Java堆和本地堆中来回复制数据.      
会出现的异常状况:OOM(OutOfMemoryError).       

- 对象  

对象的创建:①new关键字;②[clone方法](https://github.com/MelloChan/java-interview/blob/master/java-exam/src/base/create/CloneClass.java);③[反射机制](https://github.com/MelloChan/java-interview/tree/master/java-exam/src/base/reflect);④反序列化.  
 
创建过程:类加载->堆分配内存->初始化为0值->引用赋值->执行\<init>,按照使用者的意志初始化.  
 
内存的分配:①指针碰撞法,将堆划分为使用的一方与空闲的一方,中间利用指针作为分界点.要求堆内存是规整的;②空闲列表,一个记录空闲内存的列表,当对象需要分配内存时就从列表就找到一块足够大的空间进行分配.  
 
并发问题:①CAS,同步分配保证原子性;②设置TLAB,堆中设置线程私有缓存,用于空间分配,不够在另外申请; 
  
对象的内存布局:  

①对象头,包括两部分信息,一部分用于存储对象自身的运行时数据(哈希码/GC分代年龄/锁转态标志/线程持有的锁/偏向线程ID/偏向时间戳等),另一部分则是类型指针,用于指向对象的类元数据,JVM以此确定此对象是哪个类的实例.另外数组作为Java对象,对象头还有一块用于记录数组大小;    

②实例数据,对象真正存储的有效信息,是在程序代码中所定义的各种类型的字段内容;    

③对齐填充,不是必然存在的部分,仅仅起着占位符的作用,只是因为JVM的自动内存管理系统要求对象起始地址必须是8字节的整数倍(对象的大小必须是8字节的整数倍).       

对象的访问定位:  

①句柄访问,将堆分为句柄池与实例池.Java栈中本地变量表存储着指向句柄池的引用,而句柄中包含了对象实例数据与类型数据(方法区)各自的地址信息;  

②直接指针访问,栈中存储的引用直接指向堆的实例数据,而同时必须考虑如何设置访问类型数据的相关信息.  

句柄的好处在于稳定,在对象被移动时只会改变句柄中的实例数据指针,而栈引用无需改变;直接指针好处在于快速访问.  
![句柄池](https://raw.githubusercontent.com/MelloChan/java-interview/master/image/%E5%8F%A5%E6%9F%84%E6%B1%A0.jpg)  
![直接指针](https://raw.githubusercontent.com/MelloChan/java-interview/master/image/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.jpg)  

- [OOM & SOF](https://github.com/MelloChan/java-interview/blob/master/java-exam/src/jvm)  
①堆溢出;②栈溢出;③方法区和运行时常量池溢出;④本机直接内存溢出.  

- 内存模型   

![内存模型](https://raw.githubusercontent.com/MelloChan/java-interview/master/image/JMM.png)  

八种原子操作:lock(锁,将一个变量标识为一条线程独占的状态)/unlock(解锁)、read(从主内存中读取变量传输到工作内存)/load(read后执行,将传输得到的主内存变量值载入工作内存的变量副本中)、use(使用)、assign(赋值)、store(存储,作用于工作内存的变量副本,将工作内存的变量传送到主内存中)/write(写入,store后将从工作内存中得到的变量副本值写入主内存的变量中)    

缓存一致性以及如何保证:[volatile](https://github.com/MelloChan/java-interview/blob/master/content/volatile.md)    
  

- 垃圾回收算法  

对象存活的判定:  

①[引用计数法](https://github.com/MelloChan/java-interview/blob/master/java-exam/src/jvm/ReferenceCountingGC.java),当对象被引用时,对象计数器+1,当引用失效时-1;只要计数器值为0则视为可回收对象被回收.这种算法实现简单,判定效率高,但会出现循环引用问题;    

②[可达性分析](https://github.com/MelloChan/java-interview/blob/master/java-exam/src/jvm/FinalizeEscapeGC.java)通过一系列的称为"GC Roots"的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链,当一个对象到GC Roots没有任何引用链相连时,对象即不可用,将被回收.  
可作为GC Roots的对象包括:虚拟机栈中引用的对象;方法区中静态属性引用的对象;方法区中常量引用的对象;本地方法栈中JNI引用的对象.    
引用划分:强引用(引用存在则不会被回收)、软引用(OOM将要发生时会被回收)、弱引用(GC时不论内存是否足够都将被回收)、虚引用(唯一作用在某个对象被回收时能收到系统通知).  
另外,即使对象即使被分析为不可达的,也不意味着立即回收,实际上至少经历两次标记,对象才会真正被回收.第一次标记后对象会经历一次筛选过程,JVM判断对象是否有必要执行finalize()方法,当对象没有覆盖该方法或该方法已经被执行过,则虚拟机视为没必要执行finalize(),否则执行,这也是对象逃脱回收的最后一次机会.在第二次标记时,若对象仍然不被GC Roots引用,则被回收.  

回收算法:  
①标记-清除,首先标记出所有需要回收的对象,在标记完成后统一进行回收.缺点在于效率低且会产生大量的内存碎片,使大对象的分配受阻,不得不提前触发GC;  

②复制算法,将可用内存划分为大小相等的两块,其中一块作为分配区,当这块内存分配完毕,就触发GC将存活的对象复制到另一块,在把已使用过的内存空间一次清理掉.因此内存回收只针对分配区,内存分配时也不用考虑内存碎片问题,只需移动指针,顺序分配内存即可,实现简单运行高效.但缺点在于将可分配内存减少到一半代价过大.因此针对新生代,一般会采用改良后的复制算法.
将内存区域划分为8:1:1(Eden:Survivor From:Survivor To),内存分配只在Eden区和From区进行,触发GC时将存活(未达到老年代阀值)的对象复制到To区,然后清理掉Eden区和From区,此时From区和To进行身份替换(保证一个Survivor是未分配的).这种改良后的复制算法仅仅"浪费"了10%的内存空间,因此是可接受的.如果出现存活对象大于10%,To区空间不够,则需要依赖老年代进行分配担保(借空间).    

③标记-整理,复制算法主要针对内存存活率较低的区域(一般为新生代),但存活率过高时,复制的频率上升,效率也将下降.针对这种情况,在老年代中一般采取标记-整理算法.
首先标记出所有需要回收的对象,标记完成后将所有存活对象移向一端,然后直接清理掉其余内存空间.因此不会出现碎片化问题.  

④分代算法,其实就是针对对象存活率的高低采用不同回收算法.将堆分为新生代、老年代.针对两者的特性采取复制算法或标记-整理算法.    

- 垃圾收集器   

按分代:  
①新生代:Serial、ParNew、Parallel Scavenge、G1;  
②老年代:CMS、Serial Old、Parallel Old、G1.

按线程:  
①单线程:Serial、Serial Old;  
②多线程:ParNew、Parallel Scavenge、Parallel Old、CMS、G1.

- 内存分配

自动化内存管理:内存分配 & 内存回收.
![MM](https://raw.githubusercontent.com/MelloChan/java-interview/master/image/JVM-MM.png)  

内存分配:  
①[对象优先在新生代Eden区分配](https://github.com/MelloChan/java-interview/blob/master/java-exam/src/jvm/MinorGC.java).当Eden区空间不足(即需要进行对象内存分配时,剩余空间不足)时,JVM将发起一次Minor GC.      

②大对象直接进入老年代.对于JVM来说大对象的内存分配是很麻烦的(更麻烦的是生命周期短的大对象).大对象意味着需要更多的连续内存空间,经常出现大对象将导致空间还剩不少时就发生GC来为对象腾出空间.因此虚拟机提供一个 -XX:PretenureSizeThreshold 参数,设置该参数值使大于该值的对象直接分配在老年代.  

③长期存活的对象进入老年代.Eden区的对象经历一次Minor GC后仍然存活且能被Survivor区容纳的话,就会被移动到Survivor区,此时年龄为1.之后每一次Minor GC后仍然存活则年龄+1,到达阈值15(默认,可通过 -XX:MaxTenuringThreshold设置)就被转移到老年代.       

④动态对象分配.Survivor区同年龄对象达到该区域一半及以上内存占用时,年龄大于等于该年龄的对象直接进入老年代.       

⑤空间分配担保.复制算法无法保证Eden区每次存活对象一定不大于Survivor区剩余空间,因此需要借助老年代内存空间.这就需要在Minor GC前检查老年代是否是有足够的连续空间能够存放Survivor区溢出的部分.   
    
- 类加载   

类的生命周期:   
加载->(验证->准备->解析)->初始化->使用->卸载.  
这个过程中,解析步骤是不确定的.为了适应Java动态绑定特性,解析是可以在初始化之后在开始的.另外,这里的步骤并不是说一个阶段全部完成才能进行下一个阶段,而是指按部就班的开始.

类加载时机:  
JVM规范中并没有进行强制说明类加载中第一个阶段,加载开始的时机,但对于初始化(而加载、验证、准备在初始化前开始)则严格规定了以下五种情况:  
①new关键字获取对象实例或读取(设置)一个静态字段(final关键字修饰,静态常量除外,因为在编译期提前放入了常量池)以及调用一个类的静态方法;  
②反射;   
③初始化一个类的时候,如果父类没有进行过初始化,则触发父类的初始化;  
④JVM启动时,用户需要指定一个要执行的主类(main方法所在类),JVM或先初始化这个主类;  
⑤动态语言支持.  

类加载过程:
    
加载:将class文件的二进制字节码加载到JVM中;  

验证:将字节码进行验证是否符合JVM要求;  

准备:为变量进行内存分配,进行零值初始化(布尔型false,整型0,引用类型null等);    

解析:将符号引用常量解释为直接引用;    

初始化:<init>,进行构造器初始化;  

使用:正式供开发者使用,实例化;   

卸载:从JVM中卸载class文件.    


类加载器:

![双亲委派模型](https://raw.githubusercontent.com/MelloChan/java-interview/master/image/ClassLoader.png)  

启动类加载器:负责加载<Java_Home>\lib目录(或者由参数指定目录)下的rt.jar,无法被开发者直接引用,实质上分类只有启动类加载器与其他所有加载器,因为其本身是JVM的一部分,用C++实现;  

扩展类加载器:负责加载<Java_Home>\lib\ext目录中的jar包(也可由java.ext.dirs系统变量来指定类库);  

应用程序类加载器:负责加载用户类路径上所指定的类库(由ClassLoader中的getSystemClassLoader()方法获取);  

自定义加载器:用户自定义的类加载器,继承ClassLoader类,重写findClass方法.  

注意:类加载器之间的父子关系实质上是组合模式,而非继承.
   
如何判断两个类是否相同?   
类全限定名(包名&类名)+类加载器类型.

双亲委派模型:
简而言之,类加载总是逐步递交给上级加载器加载,只有父类加载器无法加载指定的类时,才会委托给子类加载器.因此启动类加载器(Bootstrap)总是被委派率先进行类加载.

作用:  
安全性,防止类混乱,例如假设存在多个java.lang.Object,那势必会使系统陷入混乱......  

自定义[java.lang.String](https://github.com/MelloChan/java-interview/blob/master/java-exam/src/java/lang/String.java)?  
可以创建这样的一个包类,也就是说可以正常编译但永远无法加载运行,另外即使强行重写defineClass()去加载这样一个类,也会抛出安全异常,因为以java开头的包名是不被允许创建,
 
